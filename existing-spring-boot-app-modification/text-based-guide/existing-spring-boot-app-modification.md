# Amplicode для разработки Spring Boot (Security + Web + Data + Flyway + Kafka) приложения

Amplicode - это набор инструментов для максимально эффективной и комфортной разработки сервисов и веб приложений на Spring Boot в IntelliJ IDEA и административного пользовательского интерфейса на React Admin в VSCode. 

Amplicode предоставляет мощную поддержку фреймворка Spring для пользователей IntelliJ IDEA, включая популярные модули, такие как Spring Boot, Spring Web, Spring Data, Spring Security и другие. Также Amplicode облегчает использование связанных с экосистемой Spring технологий, таких как Liquibase и Flyway, MapStruct и Model Mapper, Lombok, Kafka и многих других. 

Кроме того, Amplicode помогает в написании Docker и Docker Compose файлов, что может значительно облегчить процесс разработки и разворачивания приложения для тестирования или демонстрации. А для разработки frontend доступна поддержка React Admin на TypeScript в VSCode. 

К ключевым задачам Amplicode, с которыми он успешно справляется, относятся: 
* Ускорение разработчика на всех этапах с целью повышения его эффективности
* Снижение порога входа в поддерживаемые технологии для новичков
* Углубление познаний разработчиков в области corner/edge кейсов
* Придание уверенности в том, что написанный код следует лучшим практикам
* Дополнение GitHub Copilot и IntelliJ IDEA AI

Стоит отметить, что за разработкой Amplicode стоит команда с богатым опытом, насчитывающим десятилетия, и успешными продуктами с многомиллионной аудиторией. Также Amplicode гарантирует увеличение скорости создания приложений до 80%, а общей производительности команды разработчиков на 30%. 

А теперь давайте посмотрим на Amplicode в действии. 

Для того чтобы установить Amplicode, откроем IntelliJ IDEA и перейдем в секцию **Plugins**. Далее нажмем на иконку шестеренки и выберем пункт **Manage Plugin Repositories**. В открывшемся окне необходимо указать ссылку на репозиторий Amplicode. Скопируем ее из описания к этому видео. После этого, находясь на складке **Marketplace**, напишем в поле ввода `Amplicode` и нажмем кнопку **Install**. Вот и все. Осталось только перезапустить IntelliJ IDEA, и Amplicode готов к использованию.

## Обзор существующего приложения (через Amplicode Explorer)

Давайте посмотрим, как Amplicode  может помочь в разработке уже существующего Spring Boot приложения. В качестве примера возьмем довольно популярный проект Spring PetClinic и откроем его в IntelliJ IDEA. В момент первого открытия приложения Amplicode необходимо активировать. После успешной активации все возможности Amplicode станут доступны. Amplicode предоставляет возможность проанализировать приложение в контексте используемых вреймворков и библиотек с помощью панели Amplicode Explorer. Здесь мы можем узнать, какие модули подключены к нашему проекту, что из себя представляет слой данных, какие эндпоинты доступны, а также какие файлы для развертывания приложения уже есть в проекте. 

Исходя из знаний Amplicode о нашем проекте мы можем сделать следующие выводы:

* Во-первых, мы понимаем, что для удобной работы с персистентным слоем в приложении используется модуль Spring Data JPA.
* Во-вторых, к проекту подключены стартеры Spring Web и Actuator.
* В-третьих, в качестве хранилища данных используется встроенная база данных H2
* В-четвертых, мы можем более детально ознакомиться с моделью данных нашего приложения, посмотреть, какие основные сущности оьъявлены в проекте, а также каким образом они связаны друг с другом
* Наконец, все доступные MVC и REST эндпоинты представлены, как на ладони, и мы можем посмотреть их в наиболее удобном для нас представлении

Отлично! Структура проекта стала более понятной. Давайте приступим к реализации поставленной задачи. 

## Задачи на сегодня

Мы планируем внедрить следующий функционал:

* Во-первых, сделать приложение production-ready, а именно переехать с H2 и инициализировать базу данных посредством стандартного механизма Spring на PostgreSQL и Flyway в качестве системы версионирования базы данных
* Во-вторых, реализовать учет заработных плат сотрудников, расширив существующую модель данных и изменив пользовательский интерфейс (При этом важно будет сохранить обратную совместимость с имеющимся API, а также подключить и настроить Spring Security таким образом, чтобы информацию о зарплатах не могли получить все желающие)
* В-третьих, подготовить приложение к разработке мобильного клиента, а именно, реализовать REST эндпоинты для получения списка ветеринаров, а также списка ветеринаров с возможностью фильтрации их по специальностям
* В-четвертых, реализовать автоматическое назначение ветеринаров новым визитам
* Наконец, настроить оповещение сотрудников о новых визитах через интеграцию с внешним сервисом, используя Kafka

Для того чтобы следовать лучшим практикам, все сервисы, как и наше Spring Boot приложение, мы опишем в качестве контейнеров в файле Docker Compose. Исходя из опроса рабработчиков в нашем Telegram канале, многим кажется, что решение описанных выше задач могло бы занять от нескольких часов и до нескольких дней. Однако, вместе с Amplicode мы сможем выполнить все вышеперечисленные задачи менее чем за 30 минут. 

### H2 -> PostgreSQL

Первым шагом, который мы хотим предпринять, является замена встроенной базы данных H2 на PostgreSQL. Amplicode старается придерживаться подходов, с которыми многие разработчики уже давно знакомы. Например, такие действия как двойной клик, нажатие правой кнопкой мыши или комбинация клавиш для открытия файла. Amplicode с очень высокой вероятностью поймет любое из этих действий на большинстве визуальных элементов.

Нас интересует источник данных. Давайте обратимся к этому элементу в дереве, используя двойной клик. В открывшемся окне изменим тип базы данных и укажем необходимые параметры, такие как хост, порт, название базы данных, имя пользователя и пароль. Важно отметить, что Amplicode не только обновил значения свойств в файле `application.properties`, но также добавил необходимую зависимость для взаимодействия с базой данных PostgreSQL из нашего приложения. 

Благодаря панели Amplicode Designer, у нас появляется возможность исследовать, какие еще свойства, помимо уже объявленных, могут быть использованы в нашем приложении. Например, можно обратить внимание, что для группы Spring JPA нам доступно такое свойство как Auto DDL. Благодаря использованию этого свойства со значением `validate` мы можем убедиться, что JPA модель полностью соответствует схеме, заданной в базе данных. Также мы можем обратить внимание, что нам доступно свойство Show SQL. Давайте воспользуемся и им, чтобы нам было удобнее отслеживать, какие именно запросы отправляются в нашу базу данных. Осталось только изменить тип базы данных в свойстве `database` на `postgres`. 

Использовать локально поднятые сервисы в современных реалиях является дурным тоном. Из-за использования локальных сервисов возникают проблемы с переносимостью и настройкой окружения каждым из разработчиков на проекте. Намного лучше описать все необходимые сервисы в файле Docker Compose. Используя такой подход, нам достаточно иметь установленный локально Docker либо его аналог. За все остальное можно будет не переживать. Amplicode содержит узел Docker в панели Amplicode Explorer и позволяет создать файл Docker Compose по нажатию правой кнопки мыши. В открывшемся файле мы можем добавить необходимый нам сервис из числа доступных, воспользовавшись панелью Amplicode Designer, Editor Toolbar или же действием Generate от IntelliJ IDEA. 

Amplicode воспользовался уже существующим подключением к базе данных и подставил все необходимые значения в обязательные поля. Мы можем изменить любой из параметров в случае необходимости, но на текущем этапе нас все устраивает. Отлично! Сервис готов.

Давайте запустим нашу базу данных, а затем и приложение, чтобы убедиться, что все работает, как и прежде.

Переезд на Postgres успешно осуществлен. Можем двигаться дальше.

## Подключение Flyway. Генерация скрипта инициализации БД

Далее нам необходимо добавить инструменты версионирования баз данных. Помимо исследования доступных свойств с помощью Amplicode Designer мы можем настроить свойства, которые нам еще недоступны ввиду отсутствия необходимых зависимостей. Например, в секции **DB Migration** мы можем обнаружить необходимый нам **Flyway**. Стоит отметить, что помимо Flyway Amplicode может облегчить нам работу и с Liquibase. Все возможности, показанные далее, доступны также и для тех, кто предпочитает использовать Liquibase.

Оставим значение префикса-сепаратора и расположение директории, которая будет содержать сгенерированные скрипты, по умолчанию. Поскольку мы больше не будем использовать встроенные возможности Spring для создания таблиц, нам потребуется скрипт инициализации базы данных. В качестве источника данных выберем базу данных, так как мы ее успешно проинициализировали и заполнили необходимыми данными на предыдущем шаге. Для того чтобы Amplicode смог прочитать структуру базы данных и сгенерировать скрипт инициализации, необходимо создать новое подключение либо выбрать уже существующее. 

Amplicode сгенерировал для нас скрипты инициализации базы данных. Прежде чем сохранить их, мы можем убедиться, что они соответствуют нашим ожиданиям. 

Отлично! Скрипт инициализации базы данных готов. Ранее существовавшие скрипты инициализации базы данных при наполнении ее данными нам больше не нужны, поэтому давайте удалим те свойства, которые на них ссылаются. Настройка Flyway успешно завершена. 

## Изменение модели: добавление базового атрибута

Следующей задачей, которую нам предстоит решить, является реализация учета заработных плат сотрудников. Решать эту задачу начнем с расширения существующей модели данных, а именно добавления поля, содержащего информацию о зарплате, в сущность `Vet`. В открывшемся окне мы можем полностью настроить атрибут. Начнем с его типа. Хорошей практикой при работе с денежными типами данных в Java является использование `BigDecimal`. В зависимости от выбранного типа, Amplicode предоставляет дополнительные параметры настройки атрибута. В данном случае это **Precision** и **Scale**. Оставим их значения по умолчанию. Атрибут готов. 

Если обратить внимание на панель Amplicode Designer, то можем увидеть, что нам доступна секция **Validation**, так как в приложении используется одноименный стартер. Amplicode знает об этом и позволяет нам выбрать нужные валидации из множества доступных для конкретного атрибута, не обращаясь к поиску в интернете или чтению документации.

Логичной валидацией в данном случае будет `@PositiveOrZero`. Выберем ее, и Amplicode добавит соответствующую аннотацию. Теперь необходимо внести соответствующие изменения в пользовательский интерфейс, добавив новое поле. 

Мы уже выполнили половину из всех поставленных задач. Давайте запустим приложение и убедимся, что все работает так, как мы и ожидали. Приложение не запустилось и выдало ошибку, но почему?

Причина заключается в том, что мы добавили новое поле на уровне JPA, но забыли написать соответствующий скрипт для добавления этой колонки в базу данных. Благодаря свойству Hibernate `ddl-auto` со значением `validate` мы обнаружили это несоответствие сразу при запуске приложения. 

Amplicode позволяет нам вызвать действие по синхронизации модели с базой данных прямо из stacktrace. Проверим, что выбраны корректный persistence unit и подключение к базе данных и нажмем **ОК**. 

Среди всех скриптов, которые мы видим в окне предпросмотра, можно найти тот самый скрипт, который мы забыли написать для новой колонки. Однако, помимо этого скрипта есть еще более 10 скриптов, которые мы не ожидали увидеть. Давайте разберемся, в чем же дело. 

Ранее мы использовали скрипты, в которых не указывали длину для колонок с текстом. Однако, в JPA, когда мы используем аннотацию @Column, по умолчанию будет выставлена длина 255. Amplicode об этом знает и предлагает модифицировать длину существующих колонок. Так как подобное изменение может привести к потере данных, то есть, те данные, которые выходят за границу 255 символов, будут удалены, Amplicode подсвечивает нам все эти скрипты красным цветом, так как к ним требуется особое внимание со стороны разработчика. 

Если говорить о цветовой раскраске, то бывают еще скрипты, которые Amplicode отмечает желтым и зеленым цветами. По аналогии с красными скриптами, желтые могут быть потенциально опасны, а вот зеленые абсолютно безопасны и не смогут привести к потере данных. Остальные изменения, которые мы видим, точно так же появились здесь ввиду различий между JPA моделью и базой данных, которые, видимо, накопились за долгое время существования проекта.   

Давайте не будем вносить эти изменения, так как это выходит за рамки текущих задач, и перенесем их в секцию Ignored. Amplicode запомнит все эти изменения и не будет предлагать их при последующих генерациях скриптов.

Наконец, можно заметить, что в этой секции уже были некоторые скрипты. Например, скрипт по удалению индекса из базы данных. Amplicode заранее разместил эти скрипты в секцию Ignored. Такой подход выглядит довольно логичным, так как создание индекса может быть довольно дорогостоящей операцией, а его объявление на уровне модели JPA не является довольно распространенным. Поэтому удалять его мы вряд ли захотим.

Теперь скрипт нас полностью устраивает. Давайте назовем его add_salary и перезапустим приложение. У ранее созданных ветеринаров отсутствует значение для поля зарплаты. Для проверки корректности реализованной функциональности проинициализируем поля рандомными значениями. Все работает как надо.

## Подключение и настройка Spring Security

Давайте проанализируем, что мы уже сделали. Решив предыдущую задачу, мы столкнулись с небольшой проблемой безопасности. Теперь абсолютно все, даже неаутентифицированные пользователи, могут просматривать информацию о зарплатах сотрудников. Давайте сделаем так, чтобы эту информацию могли видеть только аутентифицированные пользователи. Для этого добавим Spring Security  и настроим доступ к эндпоинту.

Amplicode позволяет добавить и настроить Spring Security через панель Amplicode Explorer. Благодаря интуитивно понятным диалоговым окнам мы можем настроить один из множества наиболее популярных способов аутентификации и дополнительные параметры, специфичные для каждого из типов. В данном случае, нам подойдет базовый механизм Spring Security **HTTP session authentication**. Оставим все параметры по умолчанию и в дальнейшем сможем их изменить, если потребуется.

Наконец, мы можем еще раз убедиться в правильности настроек и увидеть, какие новые зависимости будут добавлены к проекту. Отлично! Конфигурационный класс для Spring Security готов. Давайте перезапустим наше приложение и убедимся в том, что теперь информацию о ветеринарах смогут видеть только аутентифицированные пользователи. 

Все работает, как надо. 

## Модификация существующего REST эндпоинта

Помимо MVC эндпоинтов в нашем приложении также существует один REST эндпоинт, который могут использовать наши внешние клиенты для получения информации о ветеринарах. В качестве возвращаемого значения здесь используется список сущностей. Как следствие, каждое изменение в модели, такое как добавление зарплаты или любого другого поля, будет отражаться и на клиентах. И этого мы, конечно же, не хотим.

Наиболее распространенным решением этой проблемы является использование DTO в качестве возвращаемого типа. Давайте просто изменим возвращаемый тип на не существующий пока что `VetWithoutSalaryDto`. Amplicode понял, что мы хотим сделать, и позволяет нам вызвать диалог создания DTO прямо отсюда. 

Выберем сущность для нашего DTO. Кроме того, Amplicode предлагает нам добавить MapStruct в проектБ чтобы легко осуществлять преобразования сущностей в DTO и обратно. Давайте воспользуемся этим предложением и сразу создадим абстрактный интерфейс. Сделаем DTO мутабельным и выберем все поля, кроме зарплаты. 

Для ассоциативного поля специальностей Amplicode также предлагает создать DTO. Давайте создадим DTO для специальностей прямо в текущем объекте, выбрав тип **New Nested Class**. Отлично! DTO и MapStruct интерфейс готовы к использованию. Теперь нам осталось только преобразовать список возвращаемых сущностей в список DTO. Благодаря Java Stream API мы можем это сделать довольно элегантно, а благодаря IntelliJ IDEA мы можем сразу начать писать необходимый оператор вместо предварительного преобразования списка в поток. 

Помимо встроенных вариантов от IntelliJ IDEA, мы можем также сразу заметить новую опцию `mapToVetWithoutSalaryDto` от Amplicode, которая выглядит как именно то, что мы и хотим сделать. Помимо того, что мы получили генерацию для преобразования сущности в DTO, мы также получили корректно заинжектированный Bean маппера в наш контроллер. 

Последнее, что осталось сделать - предоставить доступ к нашему эндпоинту всем без исключения. Amplicode позволяет нам сделать это прямо отсюда.В IntelliJ IDEA практически все визуальные элементы являются кликабельными. Иконки, предоставляемые Amplicode, не являются исключением. Давайте кликнем на иконку замочка и добавим правило авторизации.  

Как можно заметить, Amplicode внес изменения в существующие параметры доступа к эндпоинту. Давайте перезапустим наше приложение и убедимся в том, что все работает именно так, как мы и задумывали. 

Отлично! Все, как мы и хотели. Все приложение теперь доступно только аутентифицированным пользователям, а наш единственный REST эндпоинт - всем без исключения.

## Создание REST-контроллера с нуля

Как мы уже успели заметить ранее, в нашем приложении большинство эндпоинтов реализовано по принципу MVC, и только один из них - REST эндпоинт, оъявленный прямо в контроллере MVC. На самом деле, это не лучшая практика. Давайте подготовим наше приложение к интеграции с мобильным клиентом, создав отдельный REST  контроллер для REST эндпоинтов. Для этого прямо в дереве проекта выдовем действие **REST Controller** от Amplicode. В открывшемся окне укажем название контроллера, пакет, в котором он будет создан, и путь, по которому он будет доступен. По сути, эндпоинты, которые мы хотим реализовать, являются делегацией методов из репозитория. Amplicode предоставляет специальный диалог для делегирования любых методов из любых Bean'ов, существующих в проекте. Amplicode автоматически выбрал интерфейс `VetRepository` в качестве источника для делегирования. Это как раз то, что нам нужно. Начнем с настройки метода, отвечающего за делегирование метода `findAll`. Его название, путь и тип запроса выбраны автоматически именно такие, которые нам и нужны. 

Единственное, что нам нужно изменить - это возвращаемый тип. Как мы уже говорили ранее, возвращать сущность - не лучшая идея. Мы можем создать новую DTO и маппер к ней прямо отсюда либо воспользоваться уже существующей DTO, и именно это мы и сделаем. Перед закрытием диалога мы можем предварительно посмотреть код, который будет сгенерирован, чтобы убедиться, что мы ничего не напутали. Отлично! Помимо самого метода, Amplicode также инжектировал необходимые Bean'ы в контроллер. 

Второй метод, который мы хотим реализовать - это метод для получения ветеринаров только определенной специальности. Для этого нам понадобится добавить новый метод в репозиторий. Перейдем к нему и создадим метод поиска коллекции сущностей. В качестве параметра запроса укажем специальности, а оператором поиска будет условие `in`. Отлично! Метод готов, и теперь мы можем делегировать его прямо в контроллер, воспользовавшись опцией **Delegate to** из панели Editor Toolbar. В открывшемся окне выберем тот контроллер, в который мы хотим делегировать данный метод. 

Следующее, что нам нужно сделать - настроить параметры метода контроллера. Мы реализовали метод по поиску ветеринаров, принадлежащих к определенной специальности. Подобная реализация крайне понятна в использовании, а также более поддерживаема в дальнейшем ввиду наличия типизации. Но, реализуя REST эндпоинт, нам бы хотелось получать всех ветеринаров, принадлежащих к определенным специальностям, указывая только их идентификатор. Amplicode прекрасно понимает, что такое требование является довольно распространенным, и предоставляет удобный способ его реализации. В выпадающем списке для параметров метода `Specialties` мы можем выбрать метод уже существующего репозитория `SpecialtyRepository`, который обернет полученный из запроса идентификатор в прокси-объект без дополнительных запросов в базу данных. Наконец, аналогично ранее созданному эндпоинту, изменим возвращаемый тип на DTO. Все готово. 

Упс! Мы забыли указать путь к нашему эндпоинту. Давайте исправим это недоразумение, воспользовавшись панелью Amplicode Designer. Отлично! Все, что нам осталось сделать - настроить Spring Security. Давайте сделаем все REST эндпоинты общедоступными. Для этого воспользуемся замочком над классом и выберем в качестве правил доступа значение `Permit all`. Есть довольно много способов протестировать работоспособность нашего кода. Мы могли бы обратиться к эндпоинтам через стороннего HTTP клиента вроде Postman, через браузер, как мы это делали ранее или через curl команды прямо из терминала. Но с Amplicode для нас открывается еще одна возможность реализовать проверку, пожалуй, еще более быстрым способом и еще более полезным в дальнейшем. А именно, используя `@WebMvcTest`. 

На самом деле, тема тестирования довольно обширная и выходит за рамки наших сегодняшних целей. Более подробно мы расскажем о том, как Amplicode может помочь вам в тестировании Spring Boot приложения, в одном из следующих видео. А сегодня давайте сгенерируем тесты, которые позволят нам убедиться в том, что наши REST эндпоинты возвращают нужный статус. 

Откроем Generate меню от IntelliJ IDEA и создадим новый тестовый класс, а в качестве тестового контекста выберем Spring Boot Application. 

Будем тестировать оба наших метода, отключим CSRF и настроим входные параметры для метода поиска по специальности. Тесты готовы. Давайте их запустим. 

Все работает, как часы. 

## Изменение модели: добавление ассоциативной связи

Следующей задачей, которую мы запланировали решить, является реализация логи ки по автоматическому назначению ветеринара новому визиту. Для того чтобы реализовать подобную функциональность, нам сначала нужно вновь расширить существующую модель, добавив ассоциативную связь "Многие к одному" от визита к ветеринару. Воспользуемся уже знакомым нам действием по добавлению нового атрибута. В качестве типа атрибута укажем ветеринара. 

Все параметры в данном случае нас полностью устраивают. Стоит отметить, что Amplicode позволяет создавать любой тип ассоциативной связи; более того, он всегда сможет подсказать вам, какая из реализаций будет дучше в плане производительности, благодаря умным подсказкам.

Отлично! Атрибут готов. Не забудем внести изменения на UI, а также сгенерировать скрипт миграции. 

## Написание бизнес логики

Бизнес логику в Spring приложениях принято реализовывать в классах, помеченных аннотацией `@Service`. Давайте создадим такой класс. Помимо обычного класса, среди доступных опций можем обратить внимание на отдельно стоящий элемент **Spring Service** от Amplicode. Давайте им и воспользуемся. 

Логика нахождения подходящего ветеринара будет довольно простой. В случае, если у питомца уже были визиты в клинику, то выберем последнего ветеринара, работавшего с питомцем. В случае же, если визитов ранее не было, будем назначать любого из ветеринаров с профессией хирурга. 

Давайте приступим к реализации. Сначала получим список визитов переданного питомца. Если список пуст, то нам нужно найти любого из ветеринаров с идентификатором специальности, равным идентификатору специальности "Хирург". Для этого обратимся к интерфейсу `VetRepository` и попробуем найти подходящий метод. Вместе с Amplicode нам не нужно думать о том, какие Bean'ы уже заинжектированы в текущий сервис, а какие нет. Мы можем начать писать имя нужного нам Bean, выбрать его из списка, а Amplicode сделает все необходимое для того, чтобы мы смогли им воспользоваться.   

Среди существующих методов репозитория нам ни один не подходит. Однако есть возможность создать новый метод прямо отсюда благодаря действию `find` с многоточием. В качестве типа репозитория выберем тип поиска коллекции сущности. Amplicode открыл нам диалог создания нового метода в уже существующем репозитории. Нам для этого даже не пришлось покидать текущий редактор кода. 

Искать ветеринара будем по `id` специальности. Метод в репозитории создан, и его вызов сгенерирован в нашем сервисе. Осталось только реализовать логику нахождения ветеринара, работавшего последним с нашим питомцем. 

Вот и все. Сервис готов к использованию. Давайте воспользуемся Amplicode Explorer, чтобы быстро найти эндпоинт для создания нового визита. Скорее всего, в пути к подобному эндпоинту должны содержаться слова visit и new. Действительно, подобный POST эндпоинт существует в проекте. Первым делом обратимся к нашему сервису по имени Bean?????

<!--Имя сервиса неразборчиво-->

В текущем эндпоинте у нас еще нет объекта `pet`, есть только его идентификатор. Давайте аналогичным образом заинжектируем репозиторий для сущности `Pet` и обратимся к методу `getReferenceById`, чтобы обернуть идентификатор в объект. Вот это да! Оказывается, у нас в проекте еще не было репозитория для сущности `Pet`. Несмотря на это, Amplicode понял, что именно мы хотим сделать, и совместил сразу несколько действий в одно: создание нового репозитория, его инжекция и генерация обращений к нему.

Он настолько хорошо понимает наш проект, что предлагает заинжектировать даже еще не существующие Bean'ы. Просто фантастика!

Обратимся к методу `getReferenceById`, чтобы получить объект. Передадим его в метод сервиса и наконец установим объекту `visit` выбранного ветеринара. Отлично! Все готово. Давайте запустим приложение и попробуем создать новый визит. Ветеринар успешно назначен автоматически.

Еще одна задача решена. Можно двигаться дальше. 

## Подключение и настройка Kafka

Следующей задачей для нас будет настройка отправки сообщений в Kafka и их получение из нее. Для этого нам сначала нужно подключить саму Kafka к проекту. Давайте воспользуемся Amplicode Explorer, чтобы создать новую Kafka конфигурацию. Для настроек, связанных с Kafka, создадим новый конфигурационный класс. В качестве значения для идентификатора группы потребителей укажем `visit`, а все остальные параметры оставим по умолчанию. 

Отлично! Amplicode добавил необходимую зависимость, настроил значения в файле свойств и создал все необходимые компоненты для нашей конфигурации. Кроме того, Amplicode сразу же предлагает нам добавить Kafka в качестве сервиса в Docker Compose. Давайте, конечно же, воспользуемся этим предложением. Оставим все настройки по умолчанию и тут же запустим Kafka, чтобы убедиться, что все работает корректно. 

### Отправка сообщений в Kafka

Теперь нам нужно настроить отправку сообщений в очередь после добавления, удаления и изменения визитов в базе данных. Для этого будет удобно воспользоваться Hibernate Event Listener, чтобы отслеживать изменения с помощью механизма, представленного Hibernate. 

Откроем меню создания новых элементов в дереве проекта; в разделе **Other** найдем Hibernate Event. Выберем типы событий, на которые будет реагировать наш слушатель, и также укажем сущность. Основа для нашего слушателя готова. Теперь осталось только реализовать логику отправки сообщений в очередь. 

Не забудем изменить возвращаемое значение в методе с `false` на `true`, чтобы разрешить Hibernate выполнять свю описанную выше логику после коммита. Снова придерживаясь уже известного правила о том, что лучше отправлять DTO, а не сущность, воспользуемся постфиксом mapTo для преобразования сущности в DTO. На этот раз в качестве типа для DTO давайте выберем **Java Record**, отметим все базовые поля, а для ветеринара будем хранить только идентификатор. 

Также, создадим новый MapStruct интерфейс. Теперь воспользуемся еще одним постфиксом send, чтобы настроить отправку сообщений в очередь. Сериализаторы для ключа и значения выбраны правильно. Изменим только конфигурационный класс, в котором будет зарегистрирован новый Kafka template. 

Kafka template с нужными типами создан и уже внедрен в наш класс. Осталось только указать название очереди, в нашем случае, `visit`. Будем использовать эту логику для всех трех обработчиков событий. 

Вот и все. Отправка сообщений в очередь полностью настроена. 

### Получение сообщений из Kafka

Давайте убедимся в том, что все работает, как надо, тут же реализовав получение сообщений из брокера. Для того чтобы настроить получение сообщений из Kafka в Spring, создадим новый сервис. Механизм полученя сообщения Spring для Kafka реализуется через слушатель. Amplicode позволяет нам создать их с помощью Amplicode Designer. Выберем тип ключа и тип значения. На данный момент оставим сериализаторы, которые нам предлагает Amplicode, и в случае необходимости мы всегда сможем изменить их значения потом.

Осталось только выбрать наш конфигурационный класс, в котором будет создан необходимый компонент. Отлично! Kafka слушатель готов. Для простоты демонстрации давайте просто залоггируем то, что приходит из очереди с названием `visit`. Запустим приложение и создадим новый визит. 

Супер! Новый визит отобразился в логах. Значит, мы все сделали, как надо. 

## Контейнеризация Spring Boot приложения

В качестве финального шага давайте реализуем возможность запуска нашего приложения также из Docker Compose. С Amplicode весь процесс у нас не займет более двух минут. В Amplicode Designer, Editor Toolbar или Generate menu выберем Spring Boot приложение. Образ мы будем создавать из docker файла, который нам также предварительно потребуется создать. Включим стадию сборки нашего приложения, а настройки Gradle оставим по умолчанию. В качестве зависимых сервисов выберем Postgres.

Теперь нам нужно изменить значения свойств в `application.properties`. Так как Kafka и Postgres больше не будут располагаться на localhost, для нашего образа, поднятого в Docker, добавим переменные окружения, чтобы указать валидные пути к сервисам. Воспользуемся контекстным действием от Amplicode и добавим использование переменных окружения. Остается только указать значения, которые будут использоваться при запуске в Docker Compose.

Запустим и проверим, все ли работает, как и прежде. Отлично! Используя Docker Compose, нам не составит никакого труда задеплоить приложение для тестирования или демонстрации. Чем мы и займемся в одном из следующих видео.

## Заключение

В этом видео мы реализовали все поставленные перед нами задачи менее чем за 30 минут. На самом деле, Amplicode содержит еще множество фич, которые просто не уместились в сегодняшнее видео. Если говорить о Spring Boot, то не были показаны, но также заслуживают внимания следующие возможности Amplicode:

* Поддержка Spring Data MongoDB
* Поддержка Spring Data JDBC
* Возможность создания JPA сущностей из таблиц базы данных
* Поддержка Spring Events и Spring Cloud
* И многое другое

Кроме помощи в написании backend, Amplicode также помогает и при разработке frontend, предоставляя:

* Создание React Admin модуля
* Генерацию типовых экранов для CRUD
* Помощь в разработке экранов на React Admin

Кроме того, мы также частично продемонстрировали поддержку деплоймента в данном видео. Но на самом деле она еще более обширная и включает в себя:

* Помощь при написании GitLab/GitHub CI actions
* Поддержку при разработке Kubernetes/Helm
* А также развертывание в облаке

В ближайшем будущем мы постараемся раскрыть озвученные ранее возможности в наиболее полном объеме в отдельных видео. А если вы заинтересовались Amplicode и хотите самостоятельно изучить его возможности, то присоединяйтесь к нашему Telegram каналу. Там вы найдете все необходимое для того, чтобы начать получать максимальное удовольствие от разработки вместе с Amplicode. 

Спасибо за просмотр!