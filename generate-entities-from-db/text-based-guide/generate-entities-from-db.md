# Создание Spring Data JPA (Hibernate) сущностей из БД (PostgreSQL, MySQL, Oracle)

[![Смотреть на Youtube](images/youtube-thumbnail.png)](https://www.youtube.com/watch?v=uxdec6WIWEg)

**Примерное время прочтения: 15 минут.**

Если вы предпочитаете сначала разработать схему базы данных, а затем реализовать JPA модель, или вам необходимо создать приложение поверх уже существующей базы данных, тогда Amplicode станет для вас чрезвычайно удобным инструментом, который сэкономит много времени и избавит от рутинной работы.

Используя действие **JPA Entities from DB**, вы можете преобразовать таблицы базы данных в JPA сущности всего в несколько кликов, учитывая особенности структуры таблиц, такие как ограничения, индексы, свойства столбцов и т.д. Amplicode настолько глубоко понимает вашу модель, что может в подавляющем большинстве случаев правильно определить кардинальность, будь то один к одному, один ко многим, многие к одному или даже многие ко многим. Самое потрясающее в этом всем то, что нам не надо пересоздавать всю сущность, если что-то изменится в схеме базы данных. Вместо этого Amplicode сможет обнаружить, что именно изменилось, и внесет изменения, которые не затронут существующий код. 

Давайте посмотрим на все это в действии. 

## Задачи на сегодня

Сегодня мы будем заниматься разработкой приложения для небольшого блога. В нашей базе данных мы будем хранить пользователей, их посты, комментарии и отображать статистику: количество постов, созданных каждым пользователем. 

## Инициализация схемы БД

Для первой версии приложения нам понадобится две таблицы: `users` и `posts`. Для улучшения производительности запросов к таблице `users` создадим составной индекс для столбцов имени и фамилии. Один пользователь может создать несколько постов, поэтому кардинальность отношения - "многие к одному", реализованная через внешний ключ в таблице `posts`.

Все скрипты выполнились успешно. Давайте проверим актуальное состояние нашей базы данных, и далее можем приступать к разработке нашего Spring Boot приложения. 

## Создание Spring Boot приложения

Сгенерируем Spring Boot приложение через Spring Initializer. Установим название группы и артефакты. Добавим зависимости для Spring Data JPA и PostgreSQL. Все остальные настройки оставим по умолчанию. Далее откроем сгенерированное приложение в IntelliJ IDEA. В момент первого открытия приложения Amplicode необходимо активировать.

После успешной активации все возможности Amplicode станут доступны, и мы сможем увидеть панель Amplicode Explorer в левой нижней части экрана. 

## Настройка подключения к БД

Первое, что нам нужно сделать - это настроить источник данных для корректной работы со Spring Data JPA. Amplicode знает, что мы этого еще не сделали, и явно сигнализирует нам об этом. Вместе с Amplicode мы можем настроить источник данных довольно легко. Нажмем правой кнопкой мыши по узлу **Spring Data JPA** и выберем опцию **Create JPA Datasource**. В открывшемся окне выберем тип базы данных, в нашем случае Postgres, и укажем необходимые параметры для подключения к источнику данных. 

Благодаря действию test connection, мы можем убедиться в корректности указанных параметров для источника данных. Кроме того, мы можем сразу же создать подключение к базе данных: для этого отметим чекбокс **Create DB Connection**. Подключение к базе данных необходимо для дальнейшей корректной работы таких возможностей Amplicode как создание сущности на основе таблиц в базе данных, а также генерация скриптов миграции. В диалоге создания подключения оставим те же значения, которые мы указали для источника данных. 

Отлично! Все необходимые параметры для источника данных сгенерированы в `application.properties`, а также создано подключение к нашей базе данных. Теперь мы можем приступать к разработке JPA модели. 

## Создание JPA сущностей из таблиц базы данных

С помощью Amplicode мы можем легко справиться с задачей создания JPA модели, отталкиваясь от существующей базы данных. В дереве проекта выберем действие **JPA Entities from DB**. Далее в открывшемся окне выберем таблицу `posts`. Amplicode проанализировал структуру таблицы и предложил типы атрибутов сущности, отталкиваясь от типов столбцов таблицы. Amplicode прекрасно понимает, что некоторым типам данных в базе данных может соответствовать несколько Java классов, и выбор того или иного типа может отличаться от приложения к приложению. Поэтому Amplicode не ограничивает нас строгим соответствием, а позволяет выбрать один из доступных вариантов там, где это возможно. 

Для первичного ключа на уровне JPA будем использовать стратегию **IDENTITY**. Остается только выбрать столбец, представляющий собой внешний ключ на таблицу `users`. Amplicode знает, что для реализации ассоциативного атрибута на уровне JPA нам понадобится сущность `User`. Поэтому он автоматически выбирает связанную таблицу. Кроме того, Amplicode позволяет нам создать ассоциативный атрибут "один ко многим" от пользователей к их постам. Подобная связь не может существовать на уровне реляционной базы данных, однако является довольно удобной для JPA модели.

Таким образом, в сущности `User` мы можем хранить коллекцию постов, связанных с каждым пользователем. Стоит отметить, что несмотря на то, что наши таблицы называются во множественном числе, что является довольно распространенным подходом к именованию таблиц на уровне базы данных, на уровне JPA модели принято придерживаться именования в единственном числе. 

Amplicode автоматически установил названия для сущностей в единственном числе. Кроме того, в случае необходимости мы всегда можем изменить эти значения или даже более тонко настроить механизм именования в настройках, сконфигурировав значения полей с префиксами и постфиксами, которые можно будет пропустить при генерации названия сущности или даже через Java код без каких-либо ограничений. 


Как вы помните, у нас также есть индекс для таблицы users в базе данных. Amplicode также может реализовать его на уровне JPA модели. Для миграции существующих индексов и ограничений достаточно выбрать соответствующий чекбокс. Наконец, определим отдельный пакет для наших сущностей и сгенерируем код. Вот и все. Все сущности сгенерированы вместе с базовыми и ассоциативными атрибутами, а также индексом.

## Модификация JPA модели: создание @MappedSuperclass

Прекрасно понимая, что наше приложение со временем будет разрастаться, можно уже сейчас улучшить нашу JPA модель и подготовиться к расширению заранее. Например, идентификатор, а также все поля, связанные с аудитом, например, дата создания и последнего изменения, а также имя пользователя, выполнявшего это самое создание и изменение, будут нужны для подавляющего большинства сущностей. Для решения подобной задачи принято использовать `@MappedSuperclass`, от которого будут унаследованы все остальные сущности. Amplicode позволяет осуществить необходимый нам рефакторинг крайне удобно. 

Обратимся к диалогу создания `@MappedSuperclass`, зададим его название и отметим все атрибуты, которые нужно вынести в родительский класс. Отлично! `@MappedSuperclass` готов. Теперь мы можем применить аналогичные изменения и к сущности `User`. 

## Cherry-pick изменений из БД в JPA модель

Учесть все нюансы, разрабатывая приложение с нуля, довольно сложно. Вот и мы забыли добавить данные об электронной почте пользователя и времени его последней активности. Кроме того, мы хотели хранить информацию о комментариях пользователей к постам. Так как мы придерживаемся подхода к разработке от базы данных, сначала добавим необходимые поля в таблицу `users` и создадим новую таблицу `comments` вместе со связующей таблицей `comments_posts`. С Amplicode мы можем догенерировать недостающие атрибуты в нашу JPA модель, не потеряв при этом тех изменений, которые мы уже реализовали. 

Для внесения изменений в модель Amplicode предоставляет действие **Entity Attributes from DB**. Достичь того же самого результата мы также может и через уже известное нам диалоговое окно **JPA Entities from DB**. Для этого в списке таблиц, для которых уже есть сущность в проекте, найдем нужную нам и выберем новые поля, которые мы хотим создать. Не забудем про новую таблицу `comments`. Для нее мы можем сразу указать родительскую сущность `BaseEntity`. Amplicode отметит те атрибуты, которые будут унаследованы от базового класса. Также он корректно определил связь "многие ко многим" между постами и комментариями. Отлично! Новая сущность и связь "многие ко многим" реализована. Кроме того, новые атрибуты были добавлены в уже существующую сущность без изменения ранее написанного кода. 

## Создание JPA сущности для DB View

Последнее, что нам осталось сделать сегодня - реализовать агрегацию статистики пользователей. Для этого создадим представление на уровне базы данных, а на уровне JPA модели мы можем поступить с нашим представлением точно так же, как мы поступали с таблицей. 

Обратимся к диалогу создания сущности из базы данных и выберем наше представление. У представлений в базе данных нет первичных ключей, но у сущности JPA должен быть идентификатор. Поэтому нам нужно выбрать поле или набор полей, которые могут выступать в качестве идентификатора сущности. Идентификатор пользователя в данном случае выглядит как самый подходящий вариант. 

Вот и все. Сущность готова. Так как мы не можем сохранять данные в представлении напрямую, мы должны отметить нашу сущность аннотацией `@Immutable`. Amplicode также знает про это и уже добавил необходимую аннотацию. Кроме того, для гарантии невозможности создания новых экземпляров этой сущности Amplicode сгенерировал конструктор без параметров с модификатором `protected`.

Наконец, для всех полей были сгенерированы только геттеры, чтобы не дать разработчикам возможность изменять значения атрибутов. Подводя итог, сущность представления была сгенерирована в соответствии со всеми Best Practices. Amplicode позаботился о качестве кода за нас.

В этом видео мы увидели, как Amplicode помогает во время разработки приложения с уже существующей базой данных. Мы очень надеемся, что эти возможности сделают вашу работу еще более легкой и приятной. Спасибо за просмотр и подписывайтесь на наш Telegram канал, чтобы узнать еще больше о возможностях Amplicode.